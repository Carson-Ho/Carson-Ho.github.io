<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue） | Carson_Ho Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）">
<meta property="og:url" content="http://yoursite.com/2016/01/11/Handler源码分析/index.html">
<meta property="og:site_name" content="Carson_Ho Blog">
<meta property="og:description" content="Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/944365-71b48b7864a8b062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/944365-783bc46b43828acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/944365-41b56c716246243f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/944365-3a654c47005484ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/944365-6908dd95a1b00d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/944365-783bc46b43828acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2016-10-01T14:40:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）">
<meta name="twitter:description" content="Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/944365-71b48b7864a8b062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternative" href="/atom.xml" title="Carson_Ho Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.png" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">Carson_Ho</a></h1>
        </hgroup>

        
        <p class="header-subtitle">一个走在产品路上的Android攻城狮</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl CSDN" target="_blank" href="http://blog.csdn.net/carson_ho" title="CSDN">CSDN</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/Carson-Ho" title="github">github</a>
                            
                                <a class="fl 简书" target="_blank" href="http://www.jianshu.com/users/383970bef0a0/latest_articles" title="简书">简书</a>
                            
                                <a class="fl E-mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=mPv56uv39rbw99j_9_D1_fH0tvv39Q" title="E-mail">E-mail</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Android基础/" style="font-size: 17.5px;">Android基础</a> <a href="/tags/Android常用汇总/" style="font-size: 20px;">Android常用汇总</a> <a href="/tags/多线程-源码分析/" style="font-size: 12.5px;">多线程&源码分析</a> <a href="/tags/常用开源库使用/" style="font-size: 10px;">常用开源库使用</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/设计模式系列/" style="font-size: 15px;">设计模式系列</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Android攻城狮、产品经理、健身狂热者、球鞋Sneaker。工作邮箱：carson.ho@foxmail.com</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Carson_Ho</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Carson_Ho</a></h1>
            </hgroup>
            
            <p class="header-subtitle">一个走在产品路上的Android攻城狮</p>
            
            <nav class="header-menu">
                <ul>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="CSDN" target="_blank" href="http://blog.csdn.net/carson_ho" title="CSDN">CSDN</a>
                    
                        <a class="github" target="_blank" href="https://github.com/Carson-Ho" title="github">github</a>
                    
                        <a class="简书" target="_blank" href="http://www.jianshu.com/users/383970bef0a0/latest_articles" title="简书">简书</a>
                    
                        <a class="E-mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=mPv56uv39rbw99j_9_D1_fH0tvv39Q" title="E-mail">E-mail</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-Handler源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/11/Handler源码分析/" class="article-date">
      <time datetime="2016-01-11T11:33:26.000Z" itemprop="datePublished">2016-01-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程-源码分析/">多线程&源码分析</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近刚好在做关于异步通信的需求，那么，今天我们来讲解下Android开发中的Handler异步通信传递机制（包括Looper、Message Queue）</p>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="http://upload-images.jianshu.io/upload_images/944365-71b48b7864a8b062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler.png"></p>
<hr>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Android提供的一套消息传递机制</p>
<hr>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>用于实现子线程对UI线程的更新，实现异步消息的处理：</p>
<ul>
<li>在新启动的线程中发送消息</li>
<li>在主线程中获取并处理信息</li>
</ul>
<hr>
<h1 id="为什么要用Handler"><a href="#为什么要用Handler" class="headerlink" title="为什么要用Handler"></a>为什么要用Handler</h1><p>在安卓开发中：</p>
<ul>
<li>为了保证Android的UI操作是线程安全的，Android规定了只允许UI线程修改Activity里的UI组件；</li>
<li>但在实际开发中，必然会用到多个线程并发操作UI组件，这又将导致UI操作的线程不安全</li>
</ul>
<p>所以问题在于：如何同时满足：</p>
<ul>
<li>保证线程安全</li>
<li>使多个线程并发操作UI组件</li>
</ul>
<p>Handler消息传递机制就是这个问题的。</p>
<hr>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p><strong>主线程（UI线程）</strong></p>
<ul>
<li>定义：当程序第一次启动时，Android会同时启动一条主线程(Main Thread)</li>
<li>作用：主线程主要负责处理与UI相关的事件，所以主线程又叫UI线程<blockquote>
<p>子线程则负责一些比较耗时的操作(联网、取数据、SD卡数据加载等操作)，而主线程和子线程之间的通信,就是要靠Handler了。</p>
</blockquote>
</li>
</ul>
<p><strong>Message</strong></p>
<ul>
<li>定义：消息，理解为线程间通讯的数据单元（Handler接受和处理的消息对象。）<blockquote>
<p>例如后台线程在处理数据完毕后需要更新UI，则可发送一条包含更新信息的Message给UI线程</p>
</blockquote>
</li>
</ul>
<p><strong>Message Queue</strong></p>
<ul>
<li>定义：消息队列</li>
<li>作用：用来存放通过Handler发过来的消息，按照先进先出执行</li>
</ul>
<p><strong>Handler</strong></p>
<ul>
<li>定义：Handler是Message的主要处理者</li>
<li>作用：负责将Message添加到消息队列&amp;处理Looper分派过来的Message</li>
</ul>
<p><strong>Looper</strong></p>
<ul>
<li><p>定义：循环器，扮演Message Queue和Handler之间桥梁的角色</p>
</li>
<li><p>作用：主要负责消息循环：循环取出Message Queue的Message；消息派发：将取出的Message交付给相应的Handler</p>
<blockquote>
<ol>
<li>每个线程中只能拥有一个Looper,但是一个Looper可以和多个线程的Handler绑定起来，也就是说很多个线程可以往一个Looper所持有的MessageQueue中发送消息。这就给我们提供了线程之间通信的可能。</li>
<li>Handler在创建的时候可以显示指定Looper，这样在Handler在调用sendMessage()投递消息的时候会将消息添加到指定的Looper里面的MessageQueue。如果不指定Looper，Handler默认绑定的是创建它的线程的Looper。</li>
</ol>
</blockquote>
</li>
</ul>
<hr>
<h1 id="Handler异步通信机制工作流程图"><a href="#Handler异步通信机制工作流程图" class="headerlink" title="Handler异步通信机制工作流程图"></a>Handler异步通信机制工作流程图</h1><p><img src="http://upload-images.jianshu.io/upload_images/944365-783bc46b43828acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler异步通信传递机制流程图"></p>
<hr>
<h1 id="Handler、Looper、MessageQueue关系类图"><a href="#Handler、Looper、MessageQueue关系类图" class="headerlink" title="Handler、Looper、MessageQueue关系类图"></a>Handler、Looper、MessageQueue关系类图</h1><p><img src="http://upload-images.jianshu.io/upload_images/944365-41b56c716246243f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler、Looper、MessageQueue关系类图.png"></p>
<p><strong>Handler</strong></p>
<ul>
<li>提供sendMessage方法，将消息放置到队列中 </li>
<li>提供handleMessage方法，定义个各种消息的处理方式；</li>
</ul>
<p><strong>Looper</strong></p>
<ul>
<li>Looper.prepare()：实例化Looper对象；为当前线程生成一个消息队列；</li>
<li>Looper.loop() ：循环从消息队列中获取消息，交给Handler处理；此时线程处于无限循环中，不停的从MessageQueue中获取Message 消息 ；如果没有消息就阻塞 </li>
</ul>
<p><strong>MessageQueue</strong></p>
<ul>
<li>提供enqueueMessage 方法，将消息根据时间放置到队列中；</li>
<li>提供next方法，从队列中获取消息，没有消息的时候阻塞；</li>
</ul>
<p><strong>Handler工作流程解释</strong><br>异步通信传递机制步骤主要包括异步通信的准备、消息发送、消息循环和消息处理</p>
<ol>
<li>异步通信的准备<br>包括Looper对象的创建&amp;实例化、MessageQueue队列的创建和Handler的实例化</li>
<li>消息发送<br>Handler将消息发送到消息队列中</li>
<li>消息循环<br>Looper执行Looper.loop()进入消息循环，在这个循环过程中，不断从该Message Queue取出消息，并将取出的消息派发给创建该消息的Handler</li>
<li>消息处理<br>调用该Handler的dispatchMessage(msg)方法，即回调handleMessage(msg)处理消息</li>
</ol>
<p>好像很复杂？那就先看下这个简图了解下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944365-3a654c47005484ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="page3.png"></p>
<hr>
<h1 id="工作流程详细讲解"><a href="#工作流程详细讲解" class="headerlink" title="工作流程详细讲解"></a>工作流程详细讲解</h1><p>由上面可以得知，整个异步消息传递机制主要包括Handler、Looper和MessageQueue，接下来通过相应源码来解析这三部分</p>
<h4 id="第一部分：Looper"><a href="#第一部分：Looper" class="headerlink" title="第一部分：Looper"></a>第一部分：Looper</h4><p>Looper主要负责：</p>
<ol>
<li>自身的创建&amp;创建Message Queue</li>
<li>消息循环（消息取出、派发）</li>
</ol>
<p>对应职责我们来看下相应的源码：</p>
<ol>
<li>自身的创建&amp;创建Message Queue：prepare()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static final void prepare() &#123;</div><div class="line">//判断sThreadLocal是否为null，否则抛出异常</div><div class="line">//即Looper.prepare()方法不能被调用两次</div><div class="line">//也就是说，一个线程中只能对应一个Looper实例</div><div class="line">        if (sThreadLocal.get() != null) &#123;</div><div class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">        &#125;</div><div class="line">//sThreadLocal是一个ThreadLocal对象，用于在一个线程中存储变量</div><div class="line">//实例化Looper对象并存放在ThreadLocal</div><div class="line">//这说明Looper是存放在Thread线程里的</div><div class="line">        sThreadLocal.set(new Looper(true));</div><div class="line">&#125;</div><div class="line">//再来看下Looper的构造方法</div><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">//创建了一个MessageQueue（消息队列）</div><div class="line">//这说明，当创建一个Looper实例时，会自动创建一个与之配对的MessageQueue（消息队列）</div><div class="line">        mQueue = new MessageQueue(quitAllowed);</div><div class="line">        mRun = true;</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>2. 消息循环：loop()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static void loop() &#123;</div><div class="line">//myLooper()方法作用是返回sThreadLocal存储的Looper实例，如果me为null，loop()则抛出异常</div><div class="line">//也就是说loop方法的执行必须在prepare方法之后运行</div><div class="line">//也就是说，消息循环必须要先在线程当中创建Looper实例</div><div class="line">        final Looper me = myLooper();</div><div class="line">        if (me == null) &#123;</div><div class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">        &#125;</div><div class="line">//获取looper实例中的mQueue（消息队列）</div><div class="line">        final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line"></div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        final long ident = Binder.clearCallingIdentity();</div><div class="line">//进入消息循环</div><div class="line">        for (;;) &#123;</div><div class="line">//next()方法用于取出消息队列里的消息</div><div class="line">//如果取出的消息为空，则线程阻塞</div><div class="line">            Message msg = queue.next(); // might block</div><div class="line">            if (msg == null) &#123;</div><div class="line">          </div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">  </div><div class="line">            Printer logging = me.mLogging;</div><div class="line">            if (logging != null) &#123;</div><div class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                        msg.callback + &quot;: &quot; + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">//消息派发：把消息派发给msg的target属性，然后用dispatchMessage方法去处理</div><div class="line">//Msg的target其实就是handler对象，下面会继续分析</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">            if (logging != null) &#123;</div><div class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final long newIdent = Binder.clearCallingIdentity();</div><div class="line">            if (ident != newIdent) &#123;</div><div class="line">                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</div><div class="line">                        + Long.toHexString(ident) + &quot; to 0x&quot;</div><div class="line">                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</div><div class="line">                        + msg.target.getClass().getName() + &quot; &quot;</div><div class="line">                        + msg.callback + &quot; what=&quot; + msg.what);</div><div class="line">            &#125;</div><div class="line">//释放消息占据的资源</div><div class="line">            msg.recycle();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结Looper的作用：</p>
<ol>
<li><p>实例化本身、与当前线程绑定、创建与之相应的MessageQueue：prepare()方法</p>
<blockquote>
<p>一个线程只会有一个Looper实例，同时一个Looper实例也只有一个MessageQueue</p>
</blockquote>
</li>
<li><p>消息循环（消息取出、消息派发）：loop()方法<br>不断从MessageQueue中去取消息，派发给消息的target属性的Handler，然后调用相应Handler的dispatchMessage()方法进行消息处理。</p>
</li>
</ol>
<hr>
<h2 id="第二部分：Handler"><a href="#第二部分：Handler" class="headerlink" title="第二部分：Handler"></a>第二部分：Handler</h2><p>主要负责：</p>
<ol>
<li>在子线程发送消息给MessageQueue</li>
<li>处理Looper派发过来的消息</li>
</ol>
<p>使用Handler之前，会初始化一个Handler实例</p>
<blockquote>
<p>Handler是需要和线程绑定在一起的，在初始化Handler的时候一般通过<strong>指定Looper对象从而绑定相应线程</strong>，即给Handler指定Looper对象=绑定到了Looper对象所在的线程中，Handler的消息处理回调会在那个线程中执行。一般有两种方法创建：</p>
<ol>
<li>通过Loop.myLooper()得到当前线程的Looper对象/通过Loop.getMainLooper()可以获得当前进程的主线程的Looper对象。</li>
<li>不指定Looper对象，那么这个Handler绑定到了创建这个线程的线程上，消息处理回调也就在创建线程中执行.</li>
</ol>
</blockquote>
<p>首先看Handler的构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public Handler() &#123;</div><div class="line">        this(null, false);</div><div class="line">&#125;</div><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">//通过Looper.myLooper()获取了当前线程保存的Looper实例，如果线程没有Looper实例那么会抛出异常</div><div class="line">//这说明在一个没有创建Looper的线程中是无法创建一个Handler对象的</div><div class="line">//所以说我们在子线程中创建一个Handler时首先需要创建Looper，并且开启消息循环才能够使用这个Handler。</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        if (mLooper == null) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">        &#125;</div><div class="line">//获取了这个Looper实例中保存的MessageQueue（消息队列）</div><div class="line">//这样就保证了handler的实例与我们Looper实例中MessageQueue关联上了</div><div class="line"></div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>上述说明：当Handler初始化时，可通过构造方法自动关联Looper和相应的MessageQueue</li>
</ul>
<h4 id="1-Handler向MessageQueue发送消息：对于Handler的发送方式可以分为post和send两种方式。"><a href="#1-Handler向MessageQueue发送消息：对于Handler的发送方式可以分为post和send两种方式。" class="headerlink" title="1. Handler向MessageQueue发送消息：对于Handler的发送方式可以分为post和send两种方式。"></a>1. Handler向MessageQueue发送消息：对于Handler的发送方式可以分为post和send两种方式。</h4><p><strong>send的发送方法：sendMessage()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">   public final boolean sendMessage(Message msg)</div><div class="line">    &#123;</div><div class="line">        return sendMessageDelayed(msg, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//我们往下扒</div><div class="line">   public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = what;</div><div class="line">        return sendMessageDelayed(msg, delayMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"> public final boolean sendMessageDelayed(Message msg, long delayMillis)</div><div class="line">    &#123;</div><div class="line">        if (delayMillis &lt; 0) &#123;</div><div class="line">            delayMillis = 0;</div><div class="line">        &#125;</div><div class="line">        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"> public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">//直接获取MessageQueue</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        if (queue == null) &#123;</div><div class="line">            RuntimeException e = new RuntimeException(</div><div class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//调用了enqueueMessage方法</div><div class="line">        return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//调用sendMessage方法其实最后是调用了enqueueMessage方法</div><div class="line"> private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">//为msg.target赋值为this，也就是把当前的handler作为msg的target属性</div><div class="line">//如果大家还记得Looper的loop()方法会取出每个msg然后执行msg.target.dispatchMessage(msg)去处理消息，其实就是派发给相应的Handler</div><div class="line">        msg.target = this;</div><div class="line">        if (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(true);</div><div class="line">        &#125;</div><div class="line">//最终调用queue的enqueueMessage的方法，也就是说handler发出的消息，最终会保存到消息队列中去。</div><div class="line">        return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>Post的发送方法：sendMessage()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">showhandler.post(new Runnable() &#123;</div><div class="line">              @Override</div><div class="line">              public void run() &#123;</div><div class="line">                  String line = &quot;\n&quot;;</div><div class="line">                  StringBuffer text = new StringBuffer(show.getText());</div><div class="line">                          text.append(line).append(&quot;angelababy:Yes,I do&quot;);</div><div class="line">                          show.setText(text);</div><div class="line">              &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>相比send方法，post方法最大的不同在于，更新UI操作可直接在重写的run方法定义。</li>
<li>其实Runnable并没有创建什么线程，而是发送了一条消息，下面看源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> public final boolean post(Runnable r)</div><div class="line">    &#123;</div><div class="line">       return  sendMessageDelayed(getPostMessage(r), 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  private static Message getPostMessage(Runnable r) &#123;</div><div class="line">//创建了一个Message对象</div><div class="line">//创建Message对象可以new，也可以使用Message.obtain()方法；</div><div class="line">//但是更建议使用obtain方法，因为Message内部维护了一个Message池用于Message的复用，避免使用new 重新分配内存。</div><div class="line">        Message m = Message.obtain();</div><div class="line">//将我们创建的Runable对象作为callback属性，赋值给了此message.</div><div class="line">        m.callback = r;</div><div class="line">//创建了一个Message对象</div><div class="line">        return m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> public final boolean sendMessageDelayed(Message msg, long delayMillis)</div><div class="line">    &#123;</div><div class="line">        if (delayMillis &lt; 0) &#123;</div><div class="line">            delayMillis = 0;</div><div class="line">        &#125;</div><div class="line">        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        if (queue == null) &#123;</div><div class="line">            RuntimeException e = new RuntimeException(</div><div class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>从上面的源码发现了吧？和send中的handler.sendMessage是一样的。</p>
<blockquote>
<p>调用了sendMessageAtTime，然后调用了enqueueMessage方法，给msg.target赋值为handler，最终Handler将消息加入MessagQueue.</p>
</blockquote>
</li>
<li><p>但是细心的你会发现，在使用Post方法时会将我们创建的Runable对象作为callback属性赋值给了此message<br>那么msg的callback和target都有值，那么会执行哪个呢？<br>我们已知回调发送消息的方法是：dispatchMessage()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> public void dispatchMessage(Message msg) &#123;</div><div class="line">//一开始就会进行判断</div><div class="line">//如果msg.callback属性不为null，则执行callback回调，也就是我们的Runnable对象</div><div class="line">        if (msg.callback != null) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (mCallback != null) &#123;</div><div class="line">                if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>####2. 处理Looper派发过来的消息：dispathMessage()方法</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">        if (msg.callback != null) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (mCallback != null) &#123;</div><div class="line">                if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以看到dispathMessage()方法里调用了 handleMessage()方法，但handleMessage()是一个空方法</li>
<li>因为Handler发送消息过来是希望进行一定的处理，至于怎么处理消息是该Handler最终控制的，所以我们在创建handler时需要通过复写handleMessage()方法从而实现我们需要的消息处理方式，然后根据msg.what标识进行消息处理。</li>
</ul>
<p><strong>这就是为什么我们在主线程中实例化Handler的时候需要重写handleMessage()</strong></p>
<h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>在一个Android应用启动的时候，会创建一个主线程，即ActivityThread（也叫UI线程），在ActivityThread中有一个静态的main方法：应用程序的入口点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//一个进程会默认生成一个主线程</div><div class="line">public static void main(String[] args) &#123;</div><div class="line"> ......</div><div class="line">//主线程生成时自动通过prepareMainLooper方法为主线程创建一个Looper</div><div class="line">//prepare()方法是用于在子线程中创建一个Looper对象，在子线程中是可以退出消息循环的：调用消息队列的quit方法</div><div class="line">//Looper生成时会自动生成与之配套的消息队列</div><div class="line">Looper.prepareMainLooper(); </div><div class="line">ActivityThread thread = new ActivityThread(); </div><div class="line">thread.attach(false);</div><div class="line"> ...... </div><div class="line">//loop()方法开启消息循环</div><div class="line">//主线程的消息循环是不允许被退出的</div><div class="line">Looper.loop(); </div><div class="line">throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="第三部分：MessageQueue"><a href="#第三部分：MessageQueue" class="headerlink" title="第三部分：MessageQueue"></a>第三部分：MessageQueue</h4><p>即消息队列，用于存放Handler发送过来的消息</p>
<blockquote>
<p>为了提高插入删除的效率，采用单链表的方式实现。</p>
</blockquote>
<p>对于MessageQueue，我们来看下入队和出队操作</p>
<p><strong>MessageQueue入队</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line"></div><div class="line">        ......</div><div class="line"></div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        boolean needWake;</div><div class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">            // New head, wake up the event queue if blocked.</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; else &#123;</div><div class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class="line">            // up the event queue unless there is a barrier at the head of the queue</div><div class="line">            // and the message is the earliest asynchronous message in the queue.</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            for (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                if (p == null || when &lt; p.when) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; // invariant: p == prev.next</div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">        if (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>消息的入队（插入）过程</p>
<ul>
<li>首先判断消息队列里有没有消息，没有的话则将当前插入的消息作为队头，并且这时消息队列如果处于等待状态的话则将其唤醒。</li>
<li>若是在中间插入，则根据Message创建的时间进行插入。 </li>
</ul>
<p><strong>MessageQueue出队</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">Message next() &#123;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    int nextPollTimeoutMillis = 0;</div><div class="line">    for (;;) &#123;</div><div class="line">        if (nextPollTimeoutMillis != 0) &#123;</div><div class="line">            Binder.flushPendingCommands();</div><div class="line">        &#125;</div><div class="line">// nativePollOnce方法在native层，若是nextPollTimeoutMillis为-1，这时候消息队列处于等待状态。 　　</div><div class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            // Try to retrieve the next message.  Return if found.</div><div class="line">            final long now = SystemClock.uptimeMillis();</div><div class="line">            Message prevMsg = null;</div><div class="line">            Message msg = mMessages;</div><div class="line"></div><div class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class="line">                do &#123;</div><div class="line">                    prevMsg = msg;</div><div class="line">                    msg = msg.next;</div><div class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">            &#125;</div><div class="line">//按照我们设置的时间取出消息</div><div class="line">            if (msg != null) &#123;</div><div class="line">                if (now &lt; msg.when) &#123;</div><div class="line">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Got a message.</div><div class="line">                    mBlocked = false;</div><div class="line">                    if (prevMsg != null) &#123;</div><div class="line">                        prevMsg.next = msg.next;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mMessages = msg.next;</div><div class="line">                    &#125;</div><div class="line">                    msg.next = null;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class="line">                    msg.markInUse();</div><div class="line">                    return msg;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">// 如果消息队列中没有消息，将nextPollTimeoutMillis设为-1，下次循环消息队列则处于等待状态</div><div class="line">                nextPollTimeoutMillis = -1;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">           </div><div class="line">//退出消息队列，返回null，这时候Looper中的消息循环也会终止。 </div><div class="line">            if (mQuitting) &#123;</div><div class="line">                dispose();</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Thread、Looper、Handler之间的对应关系："><a href="#Thread、Looper、Handler之间的对应关系：" class="headerlink" title="Thread、Looper、Handler之间的对应关系："></a>Thread、Looper、Handler之间的对应关系：</h1><ul>
<li>一个Thread（线程）只能有一个Looper，可以有多个Handler</li>
<li>一个Looper可以绑定多个Handler；</li>
<li>一个Handler只能绑定一个Looper；</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/944365-6908dd95a1b00d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对应关系.png"></p>
<hr>
<h1 id="回顾工作原理图"><a href="#回顾工作原理图" class="headerlink" title="回顾工作原理图"></a>回顾工作原理图</h1><p>把Handler工作原理都讲解完了，我们再来看下一开始说的工作原理图，你大概会有更深的理解了。<br><img src="http://upload-images.jianshu.io/upload_images/944365-783bc46b43828acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler异步通信传递机制流程图"></p>
<hr>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>没有实际应用的博客都不是好博客！现在是时候看一下实际应用了</p>
<h4 id="Demo的源码下载"><a href="#Demo的源码下载" class="headerlink" title="Demo的源码下载"></a>Demo的源码下载</h4><p><a href="https://github.com/Carson-Ho/Handler_learning" target="_blank" rel="external">https://github.com/Carson-Ho/Handler_learning</a><br>（个人推荐先fork下来再对着下面的分析看，效果会更好哦！）</p>
<ol>
<li>布局文件：<br><em>activity_main</em></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;</div><div class="line">    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;</div><div class="line">    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;</div><div class="line">    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;</div><div class="line">    tools:context=&quot;com.example.carson_ho.handlerdemo.MainActivity&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/show&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;&quot; /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p><strong>2. 1  send方法：MainActivity</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.carson_ho.handlerdemo;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.os.Bundle;</div><div class="line"><span class="keyword">import</span> android.os.Handler;</div><div class="line"><span class="keyword">import</span> android.os.Message;</div><div class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</div><div class="line"><span class="keyword">import</span> android.widget.TextView;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> TextView show;</div><div class="line">    <span class="keyword">private</span> Handler showhandler;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">//主线程创建时便自动创建Looper和对应的MessageQueue,之前执行Loop()进入消息循环</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        show = (TextView) findViewById(R.id.show);</div><div class="line">    <span class="comment">//实例化Handler,这里并无指定Looper,即自动绑定当前线程(主线程)的Looper和MessageQueue</span></div><div class="line">        showhandler = <span class="keyword">new</span> FHandler();</div><div class="line">    <span class="comment">//启动子线程</span></div><div class="line">        <span class="keyword">new</span> Thread_1().start();</div><div class="line">        <span class="keyword">new</span> Thread_2().start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line">        <span class="comment">//通过复写handlerMessage()从而决定如何进行更新UI操作</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line"></div><div class="line">            StringBuffer text = <span class="keyword">new</span> StringBuffer();</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                    text.append(<span class="string">"I love Carson_Ho"</span>);</div><div class="line">                    show.setText(text);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                    text.append(<span class="string">"I hate Carson_Ho"</span>);</div><div class="line">                    show.setText(text);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Thread_1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//定义要发送的消息</span></div><div class="line">            Message msg = Message.obtain();</div><div class="line">            msg.what = <span class="number">1</span>;<span class="comment">//用于消息的标识</span></div><div class="line">            msg.obj = <span class="string">"AA"</span>;<span class="comment">//用于消息的存放</span></div><div class="line">            <span class="comment">//传入主线程的Handler并其MessageQueue发送消息</span></div><div class="line">            showhandler.sendMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Thread_2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">8000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            Message msg = Message.obtain();</div><div class="line">            msg.what = <span class="number">2</span>;</div><div class="line">            msg.obj = <span class="string">"BB"</span>;</div><div class="line">            showhandler.sendMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2. 2 Post方法：MainActivity</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">package com.example.carson_ho.handlerdemo;</div><div class="line"></div><div class="line">import android.os.Bundle;</div><div class="line">import android.os.Handler;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.widget.TextView;</div><div class="line"></div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    public TextView show;</div><div class="line">    public Handler showhandler;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    //主线程创建时便自动创建Looper和对应的MessageQueue,之前执行Loop()进入消息循环</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        show = (TextView) findViewById(R.id.AA);</div><div class="line">        StringBuffer text = new StringBuffer();</div><div class="line">        text.append(&quot;Carson_Ho:Do you love me?&quot;);</div><div class="line">        show.setText(text);</div><div class="line">    //实例化Handler,这里并无指定Looper,即自动绑定当前线程(主线程)的Looper和MessageQueue</div><div class="line">        showhandler = new Handler();</div><div class="line">    //启动子线程</div><div class="line">        new Thread_1().start();</div><div class="line">        new Thread_2().start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    class Thread_1 extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(5000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            showhandler.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    String line = &quot;\n&quot;;</div><div class="line">                    StringBuffer text = new StringBuffer(show.getText());</div><div class="line">                            text.append(line).append(&quot;angelababy:Yes,I do&quot;);</div><div class="line">                            show.setText(text);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    class Thread_2 extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(8000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            showhandler.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    String line = &quot;\n&quot;;</div><div class="line">                    StringBuffer text = new StringBuffer(show.getText());</div><div class="line">                    text.append(line).append(&quot;黄晓明:what the fuck?&quot;);</div><div class="line">                    show.setText(text);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Demo的源码下载-1"><a href="#Demo的源码下载-1" class="headerlink" title="Demo的源码下载"></a>Demo的源码下载</h1><p><a href="https://github.com/Carson-Ho/Handler_learning" target="_blank" rel="external">https://github.com/Carson-Ho/Handler_learning</a></p>
<hr>
<p><strong>参考文献</strong><br><a href="http://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/38377229</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对Handler异步通信机制全面解析（包含Looper、Message Queue）进行了全面介绍和分析，接下来我会介绍继续介绍Android开发中的相关知识，有兴趣可以继续关注[Carson_Ho的安卓开发笔记]</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/01/11/Handler源码分析/">Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Carson_Ho 的个人博客">Carson_Ho</a></p>
        <p><span>发布时间:</span>2016年01月11日 - 19时33分</p>
        <p><span>最后更新:</span>2016年10月01日 - 22时40分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/01/11/Handler源码分析/" title="Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）">http://yoursite.com/2016/01/11/Handler源码分析/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2016/01/11/Handler源码分析/　　作者: Carson_Ho" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2016/01/21/1分钟全面了解“设计模式”/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Android开发： 1分钟全面了解“设计模式”
        
      </div>
    </a>
  
  
    <a href="/2016/01/05/单例模式（Singleton）/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">单例模式（Singleton）- 最易懂的设计模式解析</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#目录"><span class="toc-number">1.1.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定义"><span class="toc-number">2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#作用"><span class="toc-number">3.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么要用Handler"><span class="toc-number">4.</span> <span class="toc-text">为什么要用Handler</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#相关概念"><span class="toc-number">5.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Handler异步通信机制工作流程图"><span class="toc-number">6.</span> <span class="toc-text">Handler异步通信机制工作流程图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Handler、Looper、MessageQueue关系类图"><span class="toc-number">7.</span> <span class="toc-text">Handler、Looper、MessageQueue关系类图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工作流程详细讲解"><span class="toc-number">8.</span> <span class="toc-text">工作流程详细讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一部分：Looper"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">第一部分：Looper</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二部分：Handler"><span class="toc-number">8.1.</span> <span class="toc-text">第二部分：Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Handler向MessageQueue发送消息：对于Handler的发送方式可以分为post和send两种方式。"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">1. Handler向MessageQueue发送消息：对于Handler的发送方式可以分为post和send两种方式。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特别注意"><span class="toc-number">8.1.1.</span> <span class="toc-text">特别注意</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第三部分：MessageQueue"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">第三部分：MessageQueue</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread、Looper、Handler之间的对应关系："><span class="toc-number">9.</span> <span class="toc-text">Thread、Looper、Handler之间的对应关系：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#回顾工作原理图"><span class="toc-number">10.</span> <span class="toc-text">回顾工作原理图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实例"><span class="toc-number">11.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo的源码下载"><span class="toc-number">11.0.0.1.</span> <span class="toc-text">Demo的源码下载</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Demo的源码下载-1"><span class="toc-number">12.</span> <span class="toc-text">Demo的源码下载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">13.</span> <span class="toc-text">总结</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/01/11/Handler源码分析/" data-title="Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）" data-url="http://yoursite.com/2016/01/11/Handler源码分析/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"null"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = '/js/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/01/21/1分钟全面了解“设计模式”/" title="上一篇: Android开发： 1分钟全面了解“设计模式”">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2016/01/05/单例模式（Singleton）/" title="下一篇: 单例模式（Singleton）- 最易懂的设计模式解析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/08/21/图片开源库/">3分钟全面了解Android主流图片加载库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/15/HandlerThread/">Android多线程全面解析：HandlerThread用法&源码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/21/详解Handler的内存泄露/">Android开发：详解Handler的内存泄露</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/工厂方法模式（Factory Method）/">工厂方法模式（Factory Method）- 最易懂的设计模式解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/推送/">史上最全解析Android消息推送解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/30/底部Tab菜单栏（FragmentTabHost+ViewPager+Fragment）/">Android开发：底部Tab菜单栏（FragmentTabHost+ViewPager+Fragment）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/20/Listview/">Android开发：ListView、AdapterView、RecyclerView全面解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/Json/">Android开发：JSON最全面解析方法(Gson、AS自带org.json、Jackson解析)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/23/五大布局属性大全/">Android开发： 五大布局属性设置大全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/12/Intent详解/">Android开发：  Intent介绍及使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/XML简介及DOM、SAX、PULL解析对比/">Android开发：XML简介及DOM、SAX、PULL解析对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/ 最全面的HTTP知识总结/">Android网络通信：最全面的HTTP知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/07/Fragment详解/">Android开发： Fragment最全面使用详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/21/Activity生命周期/">Android开发：5分钟解析Activity&Fragment生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/21/底部Tab导航栏实现（TabLayout+ViewPager+Fragment）/">Android开发：顶部&底部Tab导航栏实现（TabLayout+ViewPager+Fragment）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/21/简单工厂模式（SimpleFactoryPattern）/">简单工厂模式（SimpleFactoryPattern）- 最易懂的设计模式解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/21/1分钟全面了解“设计模式”/">Android开发： 1分钟全面了解“设计模式”</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/11/Handler源码分析/">Android开发：Handler异步通信机制全面解析（包含Looper、Message Queue）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/05/单例模式（Singleton）/">单例模式（Singleton）- 最易懂的设计模式解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/21/Android屏幕适配/">Android开发：最全面、最易懂的Android屏幕适配解决方案</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 Carson_Ho
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>